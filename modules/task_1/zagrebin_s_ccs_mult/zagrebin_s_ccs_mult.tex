\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel} % русский и переносы
\usepackage[left=1.5cm, right=2cm, top=1.5cm, bottom=1.5cm]{geometry} % поля
\setlength{\parskip}{0.5cm} % отступ между абзацами
\usepackage{amsmath}
\usepackage{hyperref}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}  % ТИТУЛЬНЫЙ ЛИСТ
Министерство науки и высшего образования Российской Федерации\\
\hfill \break
Федеральное государственное автономное образовательное\\
учреждение высшего образования\\
Национальный исследовательский Нижегородский государственный\\
университет им. Н.И. Лобачевского\\
\hfill \break
Институт информационных технологий, математики и механики\\ % 8 empty
\hfill \break \hfill \break \hfill \break \hfill \break \hfill \break \hfill \break \hfill \break \hfill \break
\large{\textbf{Отчёт по лабораторной работе\\
Умножение разреженных матриц. Элементы комплексного типа. Формат хранения матрицы – столбцовый (CCS).}} \end{center} % 5 empty
\hfill \break \hfill \break \hfill \break \hfill \break \hfill \break 
\textbf{Выполнил:} \\
студент группы 382006-2\\
Загребин С.Ю.\\
\hfill \break
\textbf{Проверил:} \\
Нестеров А.Ю.\\
младший научный сотрудник\\
\hfill \break \hfill \break \hfill \break \hfill \break \hfill \break \hfill \break 
\begin{center} Нижний Новгород\\ 2023 \end{center}
\thispagestyle{empty} % выключаем отображение номера для этой страницы
\newpage    % КОНЕЦ ТИТУЛЬНОГО ЛИСТА
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В этой лабораторной работе мы рассмотрим алгоритмы умножения разреженных матриц комплексного типа. Разреженная матрица — это матрица, в которой большинство элементов равны нулю. Для эффективного хранения и обработки таких матриц используются специальные форматы, которые позволяют сократить объем памяти и ускорить вычисления. Один из таких форматов — столбцовый (CCS), в котором хранятся только ненулевые элементы матрицы и их индексы.

Умножение матриц — это одна из основных операций в линейной алгебре, которая имеет множество приложений в науке и технике.

Различные программные средства, такие как OpenMP, TBB и std::tread, предлагают удобный интерфейс для распараллеливания программ, что позволяет ускорить вычисления.

Целью работы является сравнение производительности различных вариантов алгоритма умножения разреженных матриц на основе замеров времени выполнения.

\section*{Постановка задачи}

Написать алгоритм умножения разреженных матриц (CCS) комплексного типа и реализовать программно последовательную (без использования параллельных потоков) и параллельные версии, используя предложенные технологии (OpenMP, Intel TBB, std::thread). Описать схему распараллеливания. Провести замеры времени выполнения для каждой версии и отразить их в таблицы. Провести оценку полученных результатов эксперимента.

\section*{Описание алгоритма}

Умножение матриц заключается в нахождении скалярных произведений строк первой матрицы и столбцов второй матрицы. Для того, чтобы умножить две матрицы, необходимо, чтобы число столбцов первой матрицы совпадало с числом строк второй матрицы.

При использовании CCS формата хранения матриц левую матрицу в операции умножения необходимо транспонировать, чтобы доступ к данным везде происходил по столбцам, лежащих в непрерывных участках памяти. Указатель на начало каждого столбца находится в массиве offset.

Отличие использования CCS формата от хранения матриц в стандартном формате заключается в возможности итерироваться только по ненулевым элементам столбцов, что может существенно ускорить процесс.

Элемент с$_{ij}$ результирующей матрицы получается перемножением i-го столбца транспонированной левой матрицы и j-го столбца правой матрицы.

Формат хранения CCS требует также подсчёт числа ненулевых элементов в каждом столбце. При хранении нецелочисленных элементов нулевым элементом считаем элемент с модулем не превосходящим заданного порога.

\section*{Описание схемы распараллеливания}

При использовании формата хранения по столбцам (CCS) логично распараллеливать алгоритм по ним же. Поскольку результат вычисления каждого столбца результирующей матрицы не зависит от остальных, то параллельные реализации не требуют дополнительных усилий для обеспечения защиты потоков.

Тем не менее подсчёт ненулевых символов и заполнение данными результирующей матрицы нужно выполнять после завершения всех подсчётов, поскольку заранее число ненулевых элементов неизвестно.

\section*{Описание программной реализации}

Для всех версий программы использовался один и тот же код, заисключением функции умножения матриц - mult().

Для последовательной версии осуществляется проходом в двух вложенных циклах: внешний по колонкам правой матрицы и внутренний по колонкам трансонированной левой. Таким образом внешний цикл соответствует вычислению колонкам результирующей матрицы. Если результат перемножения колонок больше заданной величины, то он добавляется в массив элементов результирующей матрицы, а число в соответствующей колонке результирующей матрицы увеличивается на 1. После заполнения каждого столбца результирущей матрицы к массиву offset добавляется значение равное сумме значения последнего добавленного элемента и числа элементов в данном столбце.

По скольку значения столбцов результирующей матрицы не зависят друг от друга, то их вычисление может производиться параллельно, что соответствует распараллеливанию внешнего цикла в последовательной версии. Значения столбцов результирующей матрицы хранятся в отдельных контейнерах (в данной реализации использовался std::list), которые потом объединяются с заполнением массива offset.

Для каждой технологии используется свои функции распараллеливания цикла: 

\begin{enumerate}
    \item OpenMP - директива "\#pragma omp parallel for";
    \item TBB - tbb::parallel\_for с использованием tbb::blocked\_range для обхода колонок правой матрицы;
    \item std::thread создаёт поток, в который передаётся в виде анонимной функции тело внешнего цикла. 
\end{enumerate}

\section*{Результаты экспериментов}
Для компиляции всех версий использовался GCC 12.2.1 с параметром -O3. Для определения числа потоков использовались настройки по умолчанию. На вход подавались две случайные матрицы размера 1000х1000 c долей заполненности 0.2 в формате CCS.

\begin{tabular}{|c||c|c|c||c|c|} \hline
Версия & 1  & 2  & 3  & Среднее & Ускорение \\ \hline \hline
 Последовательная & 1.674 & 1.669 & 1.676 & 1.673 & 1 \\ \hline
 OpenMP           & 0.378 & 0.370 & 0.367 & 0.372 & 4.5 \\ \hline
 TBB              & 0.374 & 0.316 & 0.315 & 0.335 & 5.0 \\ \hline
 std::thread      & 0.553 & 0.501 & 0.498 & 0.517 & 3.2 \\ \hline
\end{tabular}

\section*{Выводы из результатов}
Все технологии распараллеливания показали хорошие результаты прироста скорости. Различия в технической реализации и возможностях каждой технологии определяют предпочтительный выбор в рамках конкретной задачи.

\section*{Заключение}
При использовании правильной схемы распараллеливания,  параллельная версия может значительно ускорить работу программы. Ограничения на объём кода, доступный для распараллеливания, количество доступных ядер и взаимодействие потоков существенно влияют на максимальный прирост скорости.

\section*{Литература}

1) Параллельное программирование с использованием OpenMP. Сысоев А.В..

2) Инструменты параллельного программирования для систем с общей памятью. Библиотека Intel Threading Building Blocks - краткое описание. Мееров И.Б., Сысоев А.В., Сиднев А.А..

\section*{Приложение}

Репозиторий со всеми реализациями версий алгоритма умножения разреженных матриц (формат - CCS): \url{https://github.com/sergey31415926/par_pro_2023_omp_tbb_std}

\end{document}
